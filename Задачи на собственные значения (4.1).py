#Задачи на собственные значения и собственные вектора матриц

#№ 4.1

import numpy as np

#генерация матрицы гильберта размера n x n
def generate_matrix(n):
    #подфункция, принимает i и j, возврацает число по формуле
    aij = lambda i, j: 1 / (i + j - 1)
    #создаем матрицу; + 1 т. к. индексы начинаются с 0
    mat = [[aij(i + 1, j + 1) for i in range(n)] for j in range(n)] 
    #возвращаем результат, оборачиваем в np.array
    return np.array(mat)
    
#степенной метод для матрицы A
def power_method(A):
    #создаем вектор из 1 длины, равной размеру матрицы (m.shape[0])
    q = [1] * A.shape[0]
    #нужно, чтобы q имел единичную эвклидову норму => нормируем
    q /= np.linalg.norm(q)
    
    while True:
        z = np.dot(A, q) #умножаем A на вектор q, получаем z (новое q)
        z /= np.linalg.norm(z) #нормируем z
        #если новый и старый вектор q мало отличаются (норма разности не превышает 10 в -6 степени), то заканчиваем цикл
        if np.linalg.norm(q - z) < 1e-6:
            break
        q = z
        
    return np.dot(np.dot(A, q), q), q #возвращаем собственный вектор (q) матрицы A, и собственное значение (np.dot(np.dot(A, q), q))

#цикл: n от 2 до 10
for n in range(2, 11):
    print("n =", n) #выведем n
    H = generate_matrix(n) #создадим матрицу
    print(H) #выведем матрицу
    l, v = power_method(H) #найдем наибольшее модулю собственное значение (l) матрицы и соответствующий ему собственный вектор
    print("max(abs(eigenvalue)) =", l, "\neigenvector =", v) #выведем наибольшее по модулю собственное значение матрицы и собственный вектор